<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
    <title>SpriteForge Mobile — SpriteGen</title>

    <!-- JSZip + gif.js via CDN (required for ZIP + GIF generation) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.min.js"></script>

    <style>
        :root {
            --bg: #0b0d0e;
            --panel: #111315;
            --muted: #9aa;
            --accent: #00bfff;
            --accent-active: #ff6b6b;
            --white: #eef2f3;
            --btn-h: 64px;
            --slider-w: 60px;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Inter, Arial, Helvetica, sans-serif;
            background: var(--bg);
            color: var(--white);
            -webkit-tap-highlight-color: transparent;
            overflow: hidden
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column
        }

        /* Screens */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 8px
        }

        .screen.active {
            display: flex
        }

        /* top */
        .topbar {
            width: 100%;
            text-align: center;
            padding: 8px 0
        }

        .topbar h1 {
            font-size: 18px;
            margin: 0
        }

        .topbar p {
            font-size: 12px;
            color: var(--muted);
            margin: 6px 0 0
        }

        /* upload */
        .upload-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            margin-top: 6px
        }

        .file-drop {
            width: 100%;
            max-width: 720px;
            background: linear-gradient(180deg, #121314, #0e0f10);
            border: 1px dashed rgba(255, 255, 255, 0.03);
            padding: 14px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            position: relative
        }

        .file-drop input {
            position: absolute;
            opacity: 0;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%
        }

        .file-drop svg {
            width: 44px;
            height: 44px;
            margin-bottom: 8px;
            color: var(--accent)
        }

        .thumbs-wrap {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            overflow: auto;
            padding: 6px;
            width: 100%
        }

        /* thumb wrapper + remove X */
        .thumb-wrap {
            position: relative;
            width: 84px;
            height: 84px;
            border-radius: 10px;
            overflow: visible;
            flex: 0 0 auto
        }

        .thumb-wrap img.thumb {
            width: 84px;
            height: 84px;
            object-fit: contain;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.03);
            display: block
        }

        .thumb-remove {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            z-index: 90
        }

        .thumb-remove:active {
            transform: scale(0.95)
        }

        /* buttons */
        .big-btn {
            background: var(--accent);
            color: #001820;
            border: none;
            padding: 12px 14px;
            border-radius: 12px;
            font-weight: 700;
            min-width: 160px
        }

        .big-btn[disabled] {
            opacity: .45
        }

        .hint {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px
        }

        /* editor */
        .editor-header {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 4px
        }

        .icon-back {
            background: transparent;
            border: none;
            color: var(--muted);
            padding: 8px;
            border-radius: 8px
        }

        /* canvas area */
        .canvas-wrap {
            position: relative;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: calc(100vh - 220px);
            padding: 6px
        }

        #stage {
            width: auto !important;
            height: auto !important;
            max-width: -webkit-fill-available !important;
            border-radius: 12px;
            touch-action: none;
            background: repeating-conic-gradient(#2b2b2b 0% 25%, transparent 0% 50%) 50%/20px 20px;
            border: 1px solid rgba(255, 255, 255, 0.03);
            display: block
        }

        /* slider left */
        .slider-wrap {
            position: fixed;
            left: 8px;
            top: 84px;
            bottom: 88px;
            width: var(--slider-w);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 60;
            pointer-events: auto;
            justify-content: center;

        }

        .slider-label {
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 8px
        }

        .slider-track {
            width: 10px;
            height: 60%;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .slider-handle {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: linear-gradient(180deg, #141414, #0b0b0b);
            border: 2px solid rgba(255, 255, 255, 0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-weight: 700;
            touch-action: none;
            transform: translateY(0);
            z-index: 70
        }

        .slider-hint {
            font-size: 11px;
            color: var(--muted);
            margin-top: 6px
        }

        /* bottom toolbar */
        .toolbar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            height: var(--btn-h);
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.6), #0b0b0b);
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-around;
            padding: 8px 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.03);
            z-index: 50
        }

        .tool {
            background: transparent;
            border: none;
            color: var(--accent);
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 16px
        }

        .tool svg {
            width: 26px;
            height: 26px
        }

        .tool.accent {
            background: var(--accent);
            color: #001820;
            border-radius: 10px;
            padding: 8px
        }

        .tool.active {
            color: var(--accent-active)
        }

        .tool:active {
            transform: translateY(1px)
        }

        /* result */
        .result-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 12px;
            gap: 12px;
            overflow: auto;
            width: 100%
        }

        #gifPlayer {
            width: 92%;
            max-width: 560px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            background: #111;
            padding: 6px
        }

        .frames-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            width: 100%;
            padding-bottom: 80px
        }

        .frames-grid img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.03);
            display: block
        }

        .result-actions {
            background-color: #000000c2;
            position: fixed;
            left: 0;
            right: 0;
            bottom: 10px;
            display: flex;
            gap: 8px;
            justify-content: center;
            padding: 6px;
            z-index: 80;
            flex-direction: column;
            align-items: center;
        }

        .big-btn.outline {
            background: #fff;
            border: 1px solid rgba(255, 255, 255, 0.07)
        }

        /* status */
        .status {
            position: absolute;
            left: 12px;
            top: 12px;
            background: rgba(0, 0, 0, 0.45);
            padding: 6px 8px;
            border-radius: 8px;
            font-size: 12px;
            color: var(--muted);
            z-index: 90
        }
    </style>
</head>

<body>
    <div class="app">

        <!-- UPLOAD -->
        <section id="uploadScreen" class="screen active">
            <div class="topbar">
                <h1>SpriteForge Mobile</h1>
                <p>Envie quantas imagens PNG transparentes quiser — partes, roupas e acessórios.</p>
            </div>

            <div class="upload-area">
                <label class="file-drop" aria-label="Toque para enviar imagens">
                    <input id="multiInput" type="file" accept="image/png" multiple />
                    <div style="pointer-events:none">
                        <svg viewBox="0 0 24 24">
                            <path d="M20 17.6A4 4 0 0 0 16 11h-1.26A6 6 0 1 0 6 17" stroke="currentColor"
                                stroke-width="1.6" fill="none" />
                        </svg>
                        <div style="font-size:14px;color:var(--muted)">Toque para selecionar imagens</div>
                        <div style="font-size:11px;color:rgba(255,255,255,0.06)">ou arraste (se o navegador permitir)
                        </div>
                    </div>
                </label>

                <div id="thumbsWrap" class="thumbs-wrap" aria-live="polite"></div>

                <div class="upload-actions">
                    <button id="btnToEditor" class="big-btn" disabled>Continuar para Editor</button>
                </div>
                <div class="hint">Dica: toque numa miniatura para selecioná-la no editor</div>
            </div>
        </section>

        <!-- EDITOR -->
        <section id="editorScreen" class="screen">
            <div class="editor-header">
                <button id="backToUpload" class="icon-back" aria-label="Voltar">
                    <svg viewBox="0 0 24 24">
                        <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" fill="none" />
                    </svg>
                </button>
                <div style="font-weight:700">Editor</div>
                <div style="width:44px"></div>
            </div>

            <div class="canvas-wrap">
                <div class="status" id="status">Pose: A</div>
                <canvas id="stage" aria-label="Área de edição"></canvas>
            </div>

            <!-- vertical slider left -->
            <div class="slider-wrap" id="sliderWrap">
                <div class="slider-label" id="sliderLabel">Escala</div>
                <div class="slider-track" id="sliderTrack" aria-hidden="false">
                    <div class="slider-handle" id="sliderHandle" role="slider" aria-valuemin="20" aria-valuemax="300"
                        aria-valuenow="100">⤴</div>
                </div>
                <div class="slider-hint">Arraste ↑/↓</div>
            </div>

            <!-- bottom toolbar -->
            <nav class="toolbar" role="toolbar" aria-label="Ferramentas">
                <button id="pivotEditBtn" class="tool" title="Editar pivô" aria-pressed="false">
                    <svg viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="1.6" fill="none" />
                        <path d="M12 2v3M12 19v3M2 12h3M19 12h3" stroke="currentColor" stroke-width="1.6" />
                    </svg>
                </button>

                <button id="rotateLeftBtn" class="tool" title="Girar -5°" aria-pressed="false">
                    <svg viewBox="0 0 24 24">
                        <path d="M13 3a9 9 0 0 0-9 9H1l4 4 4-4H6a7 7 0 1 1 7 7v2a9 9 0 0 0 0-18z" stroke="currentColor"
                            stroke-width="1.4" fill="none" />
                    </svg>
                </button>

                <button id="rotateRightBtn" class="tool" title="Girar +5°" aria-pressed="false">
                    <svg viewBox="0 0 24 24">
                        <path d="M11 3a9 9 0 0 1 9 9h3l-4 4-4-4h3a7 7 0 1 0-7 7v2a9 9 0 0 1 0-18z" stroke="currentColor"
                            stroke-width="1.4" fill="none" />
                    </svg>
                </button>

                <button id="bringFrontBtn" class="tool" title="Trazer para frente">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2l10 5-10 5-10-5z" stroke="currentColor" stroke-width="1.4" fill="none" />
                        <path d="M12 12v8" stroke="currentColor" stroke-width="1.4" />
                    </svg>
                </button>

                <button id="sendBackBtn" class="tool" title="Enviar para trás">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 22L2 17l10-5 10 5z" stroke="currentColor" stroke-width="1.4" fill="none" />
                        <path d="M12 12V4" stroke="currentColor" stroke-width="1.4" />
                    </svg>
                </button>

                <button id="poseAToggle" class="tool active" title="Pose A">A</button>
                <button id="poseBToggle" class="tool" title="Pose B">B</button>

                <button id="generateBtn" class="tool accent" title="Gerar sprites">▶</button>
            </nav>
        </section>

        <!-- RESULT -->
        <section id="resultScreen" class="screen">
            <div class="topbar">
                <h1>Resultado</h1>
                <p>Toque na miniatura para baixar o frame. Use os botões para baixar o ZIP (frames + spritesheet + GIF).
                </p>
            </div>

            <div class="result-content">
                <canvas id="gifPlayer" width="720" height="540" aria-label="Prévia da animação"></canvas>
                <div id="framesGrid" class="frames-grid" aria-live="polite"></div>
            </div>

            <div class="result-actions">
                <button id="downloadZipBtn" class="big-btn" disabled>Baixar ZIP</button>
                <button id="downloadSheetBtn" class="big-btn outline" disabled>Baixar spritesheet</button>
                <button id="backToEditorFromResult" class="big-btn outline">Voltar ao Editor</button>
            </div>
        </section>

    </div>

    <script>
        /* SpriteForge Mobile — completo single-file
           - Multi-upload
           - Drag, rotate (continuous while hold), pivot editing
           - Slider left to resize (visual reset on select, scale persists per-part)
           - Remove images with X
           - Pose A/B, generate 8 frames
           - Result: GIF player + grid + ZIP (frames + spritesheet + gif)
           - Mobile portrait only
        */

        // --- DOM ---
        const uploadScreen = document.getElementById('uploadScreen');
        const editorScreen = document.getElementById('editorScreen');
        const resultScreen = document.getElementById('resultScreen');

        const multiInput = document.getElementById('multiInput');
        const thumbsWrap = document.getElementById('thumbsWrap');
        const btnToEditor = document.getElementById('btnToEditor');
        const backToUpload = document.getElementById('backToUpload');

        const stage = document.getElementById('stage');
        const statusEl = document.getElementById('status');

        const pivotEditBtn = document.getElementById('pivotEditBtn');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const bringFrontBtn = document.getElementById('bringFrontBtn');
        const sendBackBtn = document.getElementById('sendBackBtn');
        const poseAToggle = document.getElementById('poseAToggle');
        const poseBToggle = document.getElementById('poseBToggle');
        const generateBtn = document.getElementById('generateBtn');

        const sliderWrap = document.getElementById('sliderWrap');
        const sliderTrack = document.getElementById('sliderTrack');
        const sliderHandle = document.getElementById('sliderHandle');
        const sliderLabel = document.getElementById('sliderLabel');

        const gifPlayer = document.getElementById('gifPlayer');
        const framesGrid = document.getElementById('framesGrid');
        const downloadZipBtn = document.getElementById('downloadZipBtn');
        const downloadSheetBtn = document.getElementById('downloadSheetBtn');
        const backToEditorFromResult = document.getElementById('backToEditorFromResult');

        // --- Canvas setup ---
        const DPR = Math.min(window.devicePixelRatio || 1, 2);
        const W = 720, H = 1080;
        stage.width = W * DPR; stage.height = H * DPR;
        stage.style.width = '100%'; stage.style.height = '100%';
        const ctx = stage.getContext('2d');
        ctx.scale(DPR, DPR);

        // gif player canvas
        const gp = gifPlayer;
        const gctx = gp.getContext('2d');

        // --- State ---
        let images = []; // {name,dataURL,img}
        let nodes = {};  // name -> {name,img,w,h,piv:{x,y}, a:{x,y,rot,scale}, b:..., z, dataURL}
        let order = [];
        let selected = null;
        let pointerDown = false;
        let dragging = null;
        let pivotMode = false;
        let editingPose = 'A';
        let frames = []; // canvases
        let spritesheetDataURL = null;
        let gifBlob = null;

        // continuous rotation
        let rotInterval = null;
        const ROT_STEP = 5;
        const ROT_TICK = 100;

        // slider drag
        let sliderActive = false;
        let sliderStartY = 0;
        let sliderStartScale = 1;
        const MIN_SCALE = 0.2, MAX_SCALE = 3.0;

        // utils
        const lerp = (a, b, t) => a + (b - a) * t;
        const lerpAngle = (a, b, t) => { let diff = ((b - a + 180) % 360) - 180; return a + diff * t; };
        const saveKey = 'spriteforge_mobile_v1';

        // --- save / restore ---
        function saveState() {
            try {
                const state = { nodes: {}, order: Object.keys(nodes).sort((a, b) => nodes[a].z - nodes[b].z), editingPose };
                for (const k of Object.keys(nodes)) {
                    const n = nodes[k];
                    state.nodes[k] = { name: n.name, piv: n.piv, a: n.a, b: n.b, z: n.z, dataURL: n.dataURL };
                }
                localStorage.setItem(saveKey, JSON.stringify(state));
            } catch (e) { console.warn('save error', e); }
        }

        function restoreState() {
            const raw = localStorage.getItem(saveKey);
            if (!raw) return false;
            try {
                const s = JSON.parse(raw);
                editingPose = s.editingPose || 'A';
                images = []; nodes = {}; order = [];
                const entries = Object.values(s.nodes || {});
                if (entries.length === 0) return false;
                let pending = entries.length;
                entries.forEach(it => {
                    const img = new Image();
                    img.onload = () => {
                        nodes[it.name] = {
                            name: it.name, img, w: img.width, h: img.height,
                            piv: it.piv || { x: Math.round(img.width / 2), y: Math.round(img.height / 2) },
                            a: it.a || { x: W / 2, y: H / 2, rot: 0, scale: 1 },
                            b: it.b || { x: W / 2, y: H / 2, rot: 0, scale: 1 },
                            z: it.z || 0,
                            dataURL: it.dataURL
                        };
                        images.push({ name: it.name, dataURL: it.dataURL, img });
                        pending--;
                        if (pending === 0) {
                            order = Object.keys(nodes).sort((a, b) => nodes[a].z - nodes[b].z);
                            selected = order[0] || null;
                            updatePoseUI();
                            render();
                            thumbsWrap.innerHTML = '';
                            images.forEach(it => {
                                const wrapper = createThumbDOM(it.name, it.dataURL);
                                thumbsWrap.appendChild(wrapper);
                            });
                            btnToEditor.disabled = false;
                        }
                    };
                    img.src = it.dataURL;
                });
                return true;
            } catch (e) { console.warn('restore error', e); return false; }
        }

        // --- upload handling ---
        multiInput.addEventListener('change', ev => {
            const files = Array.from(ev.target.files || []);
            if (files.length === 0) return;
            thumbsWrap.innerHTML = '';
            images = []; nodes = {}; order = []; selected = null;
            let pending = files.length;
            files.forEach((f, i) => {
                const fr = new FileReader();
                fr.onload = e => {
                    const dataURL = e.target.result;
                    const img = new Image();
                    img.onload = () => {
                        const base = f.name.split('.').slice(0, -1).join('.') || ('part' + i);
                        let name = base;
                        // ensure unique
                        let suffix = 1;
                        while (images.some(x => x.name === name)) { name = base + '_' + suffix; suffix++; }
                        images.push({ name, dataURL, img });
                        const wrapper = createThumbDOM(name, dataURL);
                        thumbsWrap.appendChild(wrapper);
                        pending--;
                        if (pending === 0) { createNodesFromImages(); btnToEditor.disabled = false; saveState(); }
                    };
                    img.src = dataURL;
                };
                fr.readAsDataURL(f);
            });
        });

        // create thumb DOM with remove button
        function createThumbDOM(name, dataURL) {
            const wrap = document.createElement('div');
            wrap.className = 'thumb-wrap';
            wrap.dataset.name = name;

            const thumb = document.createElement('img');
            thumb.className = 'thumb';
            thumb.src = dataURL;
            thumb.alt = name;
            wrap.appendChild(thumb);

            const btn = document.createElement('button');
            btn.className = 'thumb-remove';
            btn.type = 'button';
            btn.title = 'Remover imagem';
            btn.innerHTML = '×';
            btn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                removeImageByName(name);
            });
            wrap.appendChild(btn);

            // clicking thumb selects it (if on upload screen user wants quick select)
            wrap.addEventListener('click', () => {
                // if in editor already created nodes, select that part
                if (nodes[name]) { setSelectedAndReset(name); showScreen(editorScreen); }
            });

            return wrap;
        }

        // remove image and associated node
        function removeImageByName(name) {
            // remove from images
            images = images.filter(it => it.name !== name);
            // remove node if exists
            if (nodes[name]) { delete nodes[name]; generateOrder(); }
            // remove thumb DOM
            const wrap = Array.from(thumbsWrap.children).find(el => el.dataset && el.dataset.name === name);
            if (wrap && wrap.parentNode) wrap.parentNode.removeChild(wrap);
            // update selection
            if (selected === name) {
                const remaining = Object.keys(nodes);
                selected = remaining.length ? remaining[0] : null;
            }
            if (images.length === 0) btnToEditor.disabled = true;
            saveState(); render();
        }

        // create nodes from uploaded images
        function createNodesFromImages() {
            nodes = {}; order = [];
            const cx = W / 2, cy = H / 2;
            let z = 0;
            images.forEach((it, i) => {
                const img = it.img;
                const w = Math.max(48, Math.min(360, img.width));
                const h = Math.max(48, Math.min(360, img.height));
                const name = it.name;
                nodes[name] = {
                    name, img, w, h,
                    piv: { x: Math.round(w / 2), y: Math.round(h / 2) },
                    a: { x: cx + (i * 6 - images.length * 3), y: cy + (i % 2 ? 30 : -30), rot: 0, scale: 1 },
                    b: { x: cx + (i * 6 - images.length * 3), y: cy + (i % 2 ? 30 : -30), rot: 0, scale: 1 },
                    z: z++,
                    dataURL: it.dataURL
                };
                order.push(name);
            });
            selected = order[0] || null;
            updatePoseUI();
            render();
        }

        // --- UI navigation ---
        function showScreen(el) {
            uploadScreen.classList.remove('active');
            editorScreen.classList.remove('active');
            resultScreen.classList.remove('active');
            el.classList.add('active');
        }

        btnToEditor.addEventListener('click', () => {
            if (Object.keys(nodes).length === 0) { alert('Envie pelo menos 1 imagem.'); return; }
            showScreen(editorScreen);
            saveState();
        });
        backToUpload.addEventListener('click', () => showScreen(uploadScreen));

        // --- selection helpers ---
        function setSelectedAndReset(name) {
            setSelected(name);
            onPartSelectedVisualReset();
        }
        function setSelected(name) {
            if (!name || !nodes[name]) return;
            selected = name;
            // show scale briefly
            const n = nodes[selected]; const pose = (editingPose === 'A') ? n.a : n.b;
            sliderLabel.textContent = 'Escala: ' + Math.round((pose.scale || 1) * 100) + '%';
            setTimeout(() => sliderLabel.textContent = 'Escala', 900);
            render();
        }

        // --- drawing ---
        function drawChecker() {
            const size = 30;
            for (let y = 0; y < H; y += size) {
                for (let x = 0; x < W; x += size) {
                    const isDark = ((x / size + y / size) % 2 === 0);
                    ctx.fillStyle = isDark ? 'rgba(0,0,0,0.06)' : 'rgba(255,255,255,0.02)';
                    ctx.fillRect(x, y, size, size);
                }
            }
        }
        function drawNode(n, t) {
            if (!n.img) return;
            ctx.save();
            ctx.translate(t.x, t.y);
            ctx.rotate((t.rot || 0) * Math.PI / 180);
            ctx.scale(t.scale || 1, t.scale || 1);
            ctx.drawImage(n.img, -n.piv.x, -n.piv.y, n.w, n.h);
            ctx.restore();
        }
        function render() {
            ctx.clearRect(0, 0, W, H);
            drawChecker();
            const sorted = Object.values(nodes).sort((a, b) => a.z - b.z);
            for (const n of sorted) {
                const pose = (editingPose === 'A') ? n.a : n.b;
                drawNode(n, pose);
            }
            drawOverlays();
        }
        function drawOverlays() {
            if (!selected || !nodes[selected]) return;
            const n = nodes[selected];
            const pose = (editingPose === 'A') ? n.a : n.b;
            // bounding box
            ctx.save();
            ctx.translate(pose.x, pose.y);
            ctx.rotate((pose.rot || 0) * Math.PI / 180);
            ctx.scale(pose.scale || 1, pose.scale || 1);
            ctx.strokeStyle = '#57b27c';
            ctx.lineWidth = 2;
            ctx.strokeRect(-n.piv.x, -n.piv.y, n.w, n.h);
            ctx.restore();
            // pivot marker
            const pv = worldFromLocal(n, n.piv, (editingPose === 'A') ? 'a' : 'b');
            ctx.beginPath();
            ctx.fillStyle = pivotMode ? '#00bfff' : '#ff6b6b';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.arc(pv.x, pv.y, 8, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
        }

        // coordinate transforms
        function worldFromLocal(node, localPoint, poseKey) {
            const t = (poseKey === 'a') ? node.a : node.b;
            const x = t.x, y = t.y; const s = t.scale || 1;
            const r = (t.rot || 0) * Math.PI / 180;
            const lx = localPoint.x - node.piv.x;
            const ly = localPoint.y - node.piv.y;
            const wx = x + (lx * Math.cos(r) - ly * Math.sin(r)) * s;
            const wy = y + (lx * Math.sin(r) + ly * Math.cos(r)) * s;
            return { x: wx, y: wy };
        }
        function localFromWorld(node, worldPoint, poseKey) {
            const t = (poseKey === 'a') ? node.a : node.b;
            const x = t.x, y = t.y; const s = t.scale || 1;
            const r = (t.rot || 0) * Math.PI / 180;
            const dx = (worldPoint.x - x) / s;
            const dy = (worldPoint.y - y) / s;
            const lx = dx * Math.cos(-r) - dy * Math.sin(-r);
            const ly = dx * Math.sin(-r) + dy * Math.cos(-r);
            return { x: lx + node.piv.x, y: ly + node.piv.y };
        }

        // --- canvas interactions ---
        stage.addEventListener('pointerdown', ev => {
            ev.preventDefault();
            const rect = stage.getBoundingClientRect();
            const px = (ev.clientX - rect.left) * (W / rect.width);
            const py = (ev.clientY - rect.top) * (H / rect.height);
            pointerDown = true;

            if (pivotMode && selected && nodes[selected]) {
                const node = nodes[selected];
                const local = localFromWorld(node, { x: px, y: py }, (editingPose === 'A') ? 'a' : 'b');
                if (local.x >= 0 && local.x <= node.w && local.y >= 0 && local.y <= node.h) {
                    node.piv.x = Math.max(0, Math.min(node.w, local.x));
                    node.piv.y = Math.max(0, Math.min(node.h, local.y));
                }
                pivotMode = false; pivotEditBtn.classList.remove('active'); saveState(); render();
                return;
            }

            const sorted = Object.values(nodes).sort((a, b) => b.z - a.z);
            for (const n of sorted) {
                const local = localFromWorld(n, { x: px, y: py }, (editingPose === 'A') ? 'a' : 'b');
                if (local.x >= 0 && local.x <= n.w && local.y >= 0 && local.y <= n.h) {
                    setSelectedAndReset(n.name);
                    const pose = (editingPose === 'A') ? n.a : n.b;
                    dragging = { name: n.name, offsetX: pose.x - px, offsetY: pose.y - py };
                    render();
                    return;
                }
            }
        });

        stage.addEventListener('pointermove', ev => {
            if (!pointerDown || !dragging || pivotMode) return;
            ev.preventDefault();
            const rect = stage.getBoundingClientRect();
            const px = (ev.clientX - rect.left) * (W / rect.width);
            const py = (ev.clientY - rect.top) * (H / rect.height);
            const node = nodes[dragging.name];
            const pose = (editingPose === 'A') ? node.a : node.b;
            pose.x = px + dragging.offsetX; pose.y = py + dragging.offsetY;
            render();
        });

        window.addEventListener('pointerup', () => { pointerDown = false; dragging = null; scheduleSave(); });

        // --- tools & continuous rotation ---
        pivotEditBtn.addEventListener('click', () => { pivotMode = !pivotMode; pivotEditBtn.classList.toggle('active', pivotMode); });

        function rotateSelected(delta) {
            if (!selected) return;
            const n = nodes[selected];
            const pose = (editingPose === 'A') ? n.a : n.b;
            pose.rot = ((pose.rot || 0) + delta) % 360;
            render(); scheduleSave();
        }

        function startContinuousRotation(delta) {
            if (!selected) return;
            if (rotInterval) clearInterval(rotInterval);
            rotateSelected(delta);
            rotInterval = setInterval(() => rotateSelected(delta), ROT_TICK);
        }
        function stopContinuousRotation() { if (rotInterval) { clearInterval(rotInterval); rotInterval = null; } }

        rotateLeftBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); startContinuousRotation(-ROT_STEP); });
        rotateLeftBtn.addEventListener('pointerup', stopContinuousRotation);
        rotateLeftBtn.addEventListener('pointercancel', stopContinuousRotation);
        rotateLeftBtn.addEventListener('pointerleave', stopContinuousRotation);

        rotateRightBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); startContinuousRotation(ROT_STEP); });
        rotateRightBtn.addEventListener('pointerup', stopContinuousRotation);
        rotateRightBtn.addEventListener('pointercancel', stopContinuousRotation);
        rotateRightBtn.addEventListener('pointerleave', stopContinuousRotation);

        bringFrontBtn.addEventListener('click', () => {
            if (!selected) return;
            nodes[selected].z = Math.max(...Object.values(nodes).map(x => x.z)) + 1;
            generateOrder(); render(); scheduleSave();
        });
        sendBackBtn.addEventListener('click', () => {
            if (!selected) return;
            nodes[selected].z = Math.min(...Object.values(nodes).map(x => x.z)) - 1;
            generateOrder(); render(); scheduleSave();
        });

        poseAToggle.addEventListener('click', () => { editingPose = 'A'; updatePoseUI(); render(); scheduleSave(); });
        poseBToggle.addEventListener('click', () => { editingPose = 'B'; updatePoseUI(); render(); scheduleSave(); });

        function updatePoseUI() { if (editingPose === 'A') { poseAToggle.classList.add('active'); poseBToggle.classList.remove('active'); statusEl.textContent = 'Pose: A'; } else { poseBToggle.classList.add('active'); poseAToggle.classList.remove('active'); statusEl.textContent = 'Pose: B'; } }

        function generateOrder() { order = Object.keys(nodes).sort((a, b) => nodes[a].z - nodes[b].z); }

        // --- slider behavior ---
        function resetSliderVisual() {
            sliderHandle.style.transition = '';
            sliderHandle.style.transform = 'translateY(0px)';
            sliderHandle.dataset.offset = 0;
        }

        sliderHandle.addEventListener('pointerdown', ev => {
            if (!selected) return;
            ev.preventDefault();
            sliderActive = true;
            sliderStartY = ev.clientY;
            const node = nodes[selected];
            const pose = (editingPose === 'A') ? node.a : node.b;
            sliderStartScale = pose.scale || 1;
            sliderHandle.setPointerCapture(ev.pointerId);
        });

        sliderHandle.addEventListener('pointermove', ev => {
            if (!sliderActive || !selected) return;
            ev.preventDefault();
            const rect = sliderTrack.getBoundingClientRect();
            const total = rect.height;
            const dy = sliderStartY - ev.clientY;
            const ratio = dy / (total / 2);
            let newScale = sliderStartScale * (1 + ratio);
            if (newScale < MIN_SCALE) newScale = MIN_SCALE;
            if (newScale > MAX_SCALE) newScale = MAX_SCALE;
            const node = nodes[selected];
            const pose = (editingPose === 'A') ? node.a : node.b;
            pose.scale = newScale;
            const handleY = Math.max(-total / 2, Math.min(total / 2, ratio * (total / 2)));
            sliderHandle.style.transform = `translateY(${handleY}px)`;
            sliderHandle.dataset.offset = handleY;
            render();
        });

        sliderHandle.addEventListener('pointerup', ev => {
            if (!sliderActive) return;
            sliderActive = false;
            try { sliderHandle.releasePointerCapture(ev.pointerId); } catch (e) { }
            scheduleSave();
            sliderHandle.style.transition = 'transform 120ms ease-out';
            sliderHandle.style.transform = 'translateY(0px)';
            setTimeout(() => { sliderHandle.style.transition = ''; sliderHandle.dataset.offset = 0; }, 140);
        });
        sliderHandle.addEventListener('pointercancel', () => { sliderActive = false; sliderHandle.style.transform = 'translateY(0px)'; sliderHandle.dataset.offset = 0; });

        // when a part is selected visually reset the handle
        function onPartSelectedVisualReset() { resetSliderVisual(); }

        // thumbnail click to select (already wired in createThumbDOM)

        // --- generate frames & spritesheet & GIF ---
        generateBtn.addEventListener('click', async () => {
            if (Object.keys(nodes).length === 0) { alert('Nenhuma parte carregada.'); return; }
            generateBtn.disabled = true;
            frames = [];
            spritesheetDataURL = null;
            gifBlob = null;

            const N = 8;
            for (let i = 0; i < N; i++) {
                const t = i / (N - 1);
                const c = document.createElement('canvas');
                c.width = W; c.height = H;
                const cctx = c.getContext('2d');
                // transparent bg
                const sorted = Object.values(nodes).sort((a, b) => a.z - b.z);
                for (const n of sorted) {
                    const A = n.a, B = n.b;
                    const ix = lerp(A.x, B.x, t);
                    const iy = lerp(A.y, B.y, t);
                    const irot = lerpAngle(A.rot || 0, B.rot || 0, t);
                    const iscale = lerp(A.scale || 1, B.scale || 1, t);
                    cctx.save();
                    cctx.translate(ix, iy);
                    cctx.rotate(irot * Math.PI / 180);
                    cctx.scale(iscale, iscale);
                    cctx.drawImage(n.img, -n.piv.x, -n.piv.y, n.w, n.h);
                    cctx.restore();
                }
                frames.push(c);
            }

            // create spritesheet
            const sheet = document.createElement('canvas');
            sheet.width = W * frames.length;
            sheet.height = H;
            const sctx = sheet.getContext('2d');
            frames.forEach((c, i) => sctx.drawImage(c, i * W, 0));
            spritesheetDataURL = sheet.toDataURL('image/png');

            // generate GIF using gif.js
            // choose reasonable delay (120ms per frame), workers: 2
            try {
                const gif = new GIF({ workers: 2, quality: 10, workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.min.js' });
                frames.forEach((c) => {
                    // draw each canvas into an ImageBitmap for gif.js
                    gif.addFrame(c, { delay: 120, copy: true });
                });
                // wait for finish
                const gifPromise = new Promise((res, rej) => {
                    gif.on('finished', (blob) => res(blob));
                    gif.on('error', (err) => rej(err));
                });
                gif.render();
                gifBlob = await gifPromise;
            } catch (e) {
                console.warn('gif generation failed', e);
                gifBlob = null;
            }

            // show result UI
            displayResult();
            generateBtn.disabled = false;
        });

        // show frames grid + play gif in canvas
        function displayResult() {
            framesGrid.innerHTML = '';
            // append each frame as <img> thumbnail
            frames.forEach((c, idx) => {
                const img = document.createElement('img');
                img.src = c.toDataURL('image/png');
                img.alt = 'Frame ' + (idx + 1);
                img.addEventListener('click', () => {
                    // download single frame
                    const a = document.createElement('a'); a.href = img.src; a.download = `frame_${idx + 1}.png`; a.click();
                });
                framesGrid.appendChild(img);
            });

            // preview spritesheet small
            if (spritesheetDataURL) {
                const sp = document.createElement('img');
                sp.src = spritesheetDataURL;
                sp.alt = 'Spritesheet';
                sp.style.width = '100%';
                sp.style.borderRadius = '8px';
                framesGrid.appendChild(sp);
                downloadSheetBtn.disabled = false;
                downloadSheetBtn.onclick = () => {
                    const a = document.createElement('a'); a.href = spritesheetDataURL; a.download = 'spritesheet_8.png'; a.click();
                };
            } else {
                downloadSheetBtn.disabled = true;
            }

            // setup player: prefer GIF blob if available, else animate canvases
            if (gifBlob) {
                // show gif blob via object URL
                const url = URL.createObjectURL(gifBlob);
                const img = new Image();
                img.onload = () => {
                    // draw centered and scaled into gifPlayer canvas
                    const scale = Math.min(gp.width / img.width, gp.height / img.height);
                    gctx.clearRect(0, 0, gp.width, gp.height);
                    gctx.drawImage(img, (gp.width - img.width * scale) / 2, (gp.height - img.height * scale) / 2, img.width * scale, img.height * scale);
                    // loop preview using <img>. We set interval to redraw the <img> to handle mobile auto-stop issues
                    let playing = true;
                    let interval = setInterval(() => {
                        if (!playing) return;
                        gctx.clearRect(0, 0, gp.width, gp.height);
                        gctx.drawImage(img, (gp.width - img.width * scale) / 2, (gp.height - img.height * scale) / 2, img.width * scale, img.height * scale);
                    }, 250);
                    // free when leaving
                    resultScreen.addEventListener('transitionstart', () => { clearInterval(interval); URL.revokeObjectURL(url); });
                };
                img.src = url;
            } else {
                // animate frames canvases
                let idx = 0;
                const total = frames.length;
                const drawLoop = () => {
                    const c = frames[idx];
                    // draw c scaled into gp
                    gctx.clearRect(0, 0, gp.width, gp.height);
                    const imgW = c.width, imgH = c.height;
                    const scale = Math.min(gp.width / imgW, gp.height / imgH);
                    gctx.drawImage(c, (gp.width - imgW * scale) / 2, (gp.height - imgH * scale) / 2, imgW * scale, imgH * scale);
                    idx = (idx + 1) % total;
                    // keep a reference on element to cancel if hide
                    gp._loopId = setTimeout(drawLoop, 120);
                };
                // clear previous loop if any
                if (gp._loopId) { clearTimeout(gp._loopId); gp._loopId = null; }
                drawLoop();
            }

            // enable download zip button
            downloadZipBtn.disabled = false;
            downloadZipBtn.onclick = createZipAndDownload;

            showScreen(resultScreen);
        }

        // --- create ZIP (frames + spritesheet + gif) ---
        async function createZipAndDownload() {
            if (typeof JSZip === 'undefined') { alert('JSZip não carregado. Não é possível gerar ZIP.'); return; }
            const zip = new JSZip();
            // frames
            frames.forEach((c, i) => {
                const dataURL = c.toDataURL('image/png');
                const base64 = dataURL.split(',')[1];
                zip.file(`frames/frame_${String(i + 1).padStart(2, '0')}.png`, base64, { base64: true });
            });
            // spritesheet
            if (spritesheetDataURL) {
                zip.file('spritesheet_8.png', spritesheetDataURL.split(',')[1], { base64: true });
            }
            // gif
            if (gifBlob) {
                zip.file('animation.gif', gifBlob);
            }
            // metadata (optional)
            const meta = {
                generatedAt: (new Date()).toISOString(),
                frames: frames.length,
                parts: Object.keys(nodes).length
            };
            zip.file('metadata.json', JSON.stringify(meta, null, 2));

            // generate
            try {
                const blob = await zip.generateAsync({ type: 'blob' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'spritegen_export.zip';
                a.click();
                setTimeout(() => URL.revokeObjectURL(a.href), 5000);
            } catch (e) {
                console.error('zip error', e);
                alert('Falha ao gerar ZIP: ' + e.message);
            }
        }

        // --- save scheduling ---
        let saveTimer = null;
        function scheduleSave() { if (saveTimer) clearTimeout(saveTimer); saveTimer = setTimeout(() => saveState(), 400); }

        // --- restore on load if available ---
        (function initRestore() {
            const ok = restoreState();
            if (ok) btnToEditor.disabled = false;
        })();

        // --- helpers / debug exposure ---
        function generateOrder() { order = Object.keys(nodes).sort((a, b) => nodes[a].z - nodes[b].z); }
        resetSliderVisual();
        render();
        window._sf = { nodes, images, render, setSelectedAndReset };

    </script>
</body>

</html>